---
layout:     post   				    # 使用的布局（不需要改）
title:      Java并发编程的艺术，解读并发编程的优缺点				# 标题 
subtitle:   多核的CPU的背景下，催生了并发编程的趋势，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。  #副标题
date:       2019-07-27				# 时间
author:     凌洛 						# 作者
header-img: https://oss-weslie.oss-cn-shanghai.aliyuncs.com/data/blog_post_bg/post-bg-code2.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Java
---

# 使用并发的原因
多核的CPU的背景下，催生了并发编程的趋势，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。

在特殊的业务场景下先天的就适合于并发编程。 比如在图像处理领域，一张1024X768像素的图片，包含达到78万6千多个像素。即时将所有的像素遍历一边都需要很长的时间， 面对如此复杂的计算量就需要充分利用多核的计算的能力。又比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存， 生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。 面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。

# 并发编程的缺点
## 频繁的上下文切换
时间片是CPU分配给各个线程的时间，因为时间非常短，所以CPU不断通过切换线程，让我们觉得多个线程是同时执行的，时间片一般是几十毫秒。 而每次切换时，需要保存当前的状态起来，以便能够进行恢复先前状态，而这个切换时非常损耗性能， 过于频繁反而无法发挥出多线程编程的优势。 通常减少上下文切换可以采用无锁并发编程，CAS算法，使用最少的线程和使用协程。

- 无锁并发编程：可以参照concurrentHashMap锁分段的思想，不同的线程处理不同段的数据， 这样在多线程竞争的条件下，可以减少上下文切换的时间
- CAS算法，利用Atomic下使用CAS算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换
- 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

由于上下文切换也是个相对比较耗时的操作，所以在《Java并发编程的艺术》一书中有过一个实验，并发累加未必会比串行累加速度要快。 可以使用Lmbench3测量上下文切换的时长，vmstat测量上下文切换次数。
#线程安全
多线程编程中最难以把握的就是临界区线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。
```java
public class DeadLockDemo {
    private static String resource_a = "A";
    private static String resource_b = "B";

    public static void main(String[] args) {
        deadLock();
    }

    public static void deadLock() {
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resource_a) {
                    System.out.println("get resource a");
                    try {
                        Thread.sleep(3000);
                        synchronized (resource_b) {
                            System.out.println("get resource b");
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resource_b) {
                    System.out.println("get resource b");
                    synchronized (resource_a) {
                        System.out.println("get resource a");
                    }
                }
            }
        });
        threadA.start();
        threadB.start();

    }
}
```  
那么，通常可以用如下方式避免死锁的情况：

- 避免一个线程同时获得多个锁；
- 避免一个线程在锁内部占有多个资源，尽量保证每个锁只占用一个资源；
- 尝试使用定时锁，使用lock.tryLock(timeOut)，当超时等待时当前线程不会阻塞；
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况
# 学习并发中遇到的一些概念
## 线程
线程是依附于进程的，** 进程是分配资源的最小单位，一个进程可以生成多个线程，这些线程拥有共享的进程资源。** 就每个线程而言，只有很少的独有资源， 如：控制线程运行的线程控制块，保留局部变量和少数参数的栈空间等。 在线程的生命周期中，它要经过**新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)**5种状态。

![线程](https://oss-weslie.oss-cn-shanghai.aliyuncs.com/%E5%9B%BE%E7%89%87/github%E5%8D%9A%E5%AE%A2%E5%9B%BE/b175ae83b1433f00d59089875cc18d8562af4ae6.png)

## 同步 VS 异步
同步和异步通常用来形容一次方法调用。

- 同步调用，就是调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。
- 异步调用，就是调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。
**来个比喻：超市购物和网上购物**

- 同步调用，就像在超市购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能去收银台付款。
- 异步调用，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。

## 并发与并行
并发和并行的区别就是一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。
- 并发是逻辑上的同时发生
- 并行是物理上的同时发生。
- 并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。
- 并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。

**来个比喻：并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头。**
下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况。 假设每个核心有两个线程，那么每个CPU中两个线程会交替并发，两个CPU之间的操作会并行运算。 单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题，其本身运行效率并没有提高， 多CPU的并行运算才真正解决了运行效率问题，这也正是并发和并行的区别。

![并发与并行](https://oss-weslie.oss-cn-shanghai.aliyuncs.com/%E5%9B%BE%E7%89%87/github%E5%8D%9A%E5%AE%A2%E5%9B%BE/2048e673ca173deae0424893bde69cdac7b556f0.png)
## 阻塞和非阻塞
阻塞和非阻塞通常用来**形容多线程间的相互影响**。 比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放， 会导致等待的线程挂起，这种情况就是阻塞， 而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。
## 临界区
临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。 但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。
